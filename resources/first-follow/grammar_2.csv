Rules ,Non-Terminal,First,Follow,,,,
program → declaration-list EOF,program,"int, void",$$,,,,
declaration-list → declaration declaration-list-a,declaration-list,"int, void","(, ;, EOF, ID, NUM, break, continue, if, return, switch, while, {",,,,
declaration-list-a → declaration declaration-list-a | ε,declaration-list-a,"EPSILON, int, void","(, ;, EOF, ID, NUM, break, continue, if, return, switch, while, {",,,,
declaration → type-specifier ID declaration-a,declaration,"int, void","(, ;, EOF, ID, NUM, break, continue, if, int, return, switch, void, while, {",,,,
declaration-a → var-declaration | fun-declaration,var-declaration,"int, void","(, ;, EOF, ID, NUM, break, continue, if, int, return, switch, void, while, {",,,,
var-declaration → ; | [ NUM ] ;, | [ NUM ] ,var-declaration-a,";, [","(, ;, EOF, ID, NUM, break, continue, if, int, return, switch, void, while, {",,,
type-specifier → int | void,type-specifier,"int, void",ID,,,,
fun-declaration → ( params ) compound-stmt,fun-declaration,"int, void","(, ;, EOF, ID, NUM, break, continue, if, int, return, switch, void, while, {",,,,
params → void params-a | int ID param-a param-list,params,"int, void",),,,,
params-a → ID param-a param-list | ε,param-list,"int, void",),,,,
"param-list → , param param-list | ε",param-list-a,",, EPSILON",),,,,
param → type-specifier ID param-a,param,"int, void","), ,",,,,
param-a → ε | [ ],param-a,"EPSILON, [","), ,",,,,
compound-stmt → { declaration-list statement-list },compound-stmt,{,"(, ;, EOF, ID, NUM, break, case, continue, default, else, if, int, return, switch, void, while, {, }",,,,
statement-list → statement statement-list | ε,statement-list,"(, ;, EPSILON, ID, NUM, break, continue, if, return, switch, while, {","case, default, }",,,,
statement → expression-stmt | compound-stmt | selection-stmt | iteration-stmt | return-stmt | switch-stmt,statement,"(, ;, ID, NUM, break, continue, if, return, switch, while, {","(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,,,
expression-stmt → expression ; | continue ; | break ; | ;, continue , | break , | ,,expression-stmt,"(, ;, ID, NUM, break, continue","(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }"
selection-stmt → if ( expression ) statement else statement,selection-stmt,if,"(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,,,
iteration-stmt → while ( expression ) statement,iteration-stmt,while,"(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,,,
return-stmt → return return-stmt-a,return-stmt,return,"(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,,,
return-stmt-a → ; | expression ;, | expression ,,return-stmt-a,"(, ;, ID, NUM","(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,
switch-stmt → switch ( expression ) { case-stmts default-stmt },switch-stmt,switch,"(, ;, ID, NUM, break, case, continue, default, else, if, return, switch, while, {, }",,,,
case-stmts → case-stmt case-stmts | ε,case-stmts,"EPSILON, case",default,,,,
case-stmt → case NUM : statement-list,case-stmt,case,"case, default",,,,
default-stmt → default : statement-list | ε,default-stmt,"EPSILON, default",},,,,
expression → expression-a | ( expression ) term-a additive-expression-a simple-expression | NUM term-a additive-expression-a simple-expression,expression,"(, ID, NUM","), ,, ;, ]",,,,
expression-a → var-a expression-b | call term-a additive-expression-a simple-expression,var,ID,"), *, +, ,, -, ;, <, =, ==, ]",,,,
expression-b → term-a additive-expression-a simple-expression | ε,var-a,"EPSILON, [","), *, +, ,, -, ;, <, =, ==, ]",,,,
var → ID var-a,simple-expression,"(, ID, NUM","), ,, ;, ]",,,,
var-a → ε | [ expression ],simple-expression-a,"<, ==, EPSILON","), ,, ;, ]",,,,
simple-expression → relop additive-expression | ε,relop,"<, ==","(, ID, NUM",,,,
relop → < | ==,additive-expression,"(, ID, NUM","), ,, ;, <, ==, ]",,,,
additive-expression → term additive-expression-a,additive-expression-a,"+, -, EPSILON","), ,, ;, <, ==, ]",,,,
additive-expression-a → addop term additive-expression-a | ε,addop,"+, -","(, ID, NUM",,,,
addop → + | -,term,"(, ID, NUM","), +, ,, -, ;, <, ==, ]",,,,
term → factor term-a,term-a,"*, EPSILON","), +, ,, -, ;, <, ==, ]",,,,
term-a → * factor term-a | ε,factor,"(, ID, NUM","), *, +, ,, -, ;, <, ==, ]",,,,
factor → ( expression ) | ID factor-a | NUM factor-a → var-a | call,call,ID,"), *, +, ,, -, ;, <, ==, ]",,,,
call → ( args ),args,"(, EPSILON, ID, NUM",),,,,
args → arg-list | ε,arg-list,"(, ID, NUM",),,,,
arg-list → expression arg-list-a,arg-list-a,",, EPSILON",),,,,
"arg-list-a → , expression arg-list-a | ε",,,,,,,
